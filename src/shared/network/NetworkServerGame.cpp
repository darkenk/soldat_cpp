// automatically converted
#include "NetworkServerGame.hpp"
#include "NetworkServer.hpp"
#include "../../server/Server.hpp"
#include "../../server/ServerHelper.hpp"
#include "../Game.hpp"
#include "NetworkServerConnection.hpp"
#include "NetworkServerMessages.hpp"
#include "NetworkUtils.hpp"
#include "common/Util.hpp"
#include "shared/mechanics/SpriteSystem.hpp"
#include "shared/misc/GlobalSystems.hpp"
#include <string>

void serverhandleplayerdisconnect(tmsgheader* netmessage, std::int32_t size, NetworkServer& network, TServerPlayer* player)
{
  auto &sprite_system = SpriteSystem::Get();
  tmsg_playerdisconnect *playermsg;
  std::int32_t i;
  std::int32_t j;

  if (!verifypacket(sizeof(tmsg_playerdisconnect), size, msgid_playerdisconnect))
  {
    return;
  }

  playermsg = pmsg_playerdisconnect(netmessage);
  i = player->spritenum;

  for (j = 0; j <= sprite_system.GetSprite(i).bulletcheckamount; j++)
  {
    sprite_system.GetSprite(i).bulletcheck[j] = 0;
  }

  sprite_system.GetSprite(i).bulletcheckindex = 0;
  sprite_system.GetSprite(i).bulletcheckamount = 0;

  messagesasecnum[playermsg->num] += 1;

  if ((GS::GetGame().IsVoteActive()) && (GS::GetGame().GetVoteType() == vote_kick))
  {
    if (strtoint(GS::GetGame().GetVoteTarget()) == i)
    {
      kickplayer(i, true, kick_voted, five_minutes, "Vote Kicked (Left game)");
      GS::GetGame().stopvote();
      return;
    }
  }

  switch (sprite_system.GetSprite(i).player->team)
  {
  case team_none:
    GS::GetMainConsole().console(sprite_system.GetSprite(i).player->name + " has left the game.",
                                 enter_message_color);
    break;
  case team_alpha:
    GS::GetMainConsole().console(sprite_system.GetSprite(i).player->name + " has left alpha team.",
                                 alphaj_message_color);
    break;
  case team_bravo:
    GS::GetMainConsole().console(sprite_system.GetSprite(i).player->name + " has left bravo team.",
                                 bravoj_message_color);
    break;
  case team_charlie:
    GS::GetMainConsole().console(
      sprite_system.GetSprite(i).player->name + " has left charlie team.", charliej_message_color);
    break;
  case team_delta:
    GS::GetMainConsole().console(sprite_system.GetSprite(i).player->name + " has left delta team.",
                                 deltaj_message_color);
    break;
  case team_spectator:
    GS::GetMainConsole().console(sprite_system.GetSprite(i).player->name + " has left spectators",
                                 deltaj_message_color);
    break;
  }

  for (j = 1; j <= max_players; j++)
  {
    if ((trim(tklist[j]).empty()) || (tklist[j] == sprite_system.GetSprite(i).player->ip))
    {
      tklistkills[j] = sprite_system.GetSprite(i).player->tkwarnings;
      tklist[j] = sprite_system.GetSprite(i).player->ip;
      break;
    }
  }

  serverplayerdisconnect(i, kick_leftgame);

  if (sprite_system.GetSprite(i).isnotspectator())
  {
    sprite_system.GetSprite(i).dropweapon();
  }
  sprite_system.GetSprite(i).player->muted = 0;
  sprite_system.GetSprite(i).player->tkwarnings = 0;

#ifdef SCRIPT
  scrptdispatcher.onleavegame(SpriteSystem::Get().GetSprite(i).num, false);
#endif

  // NOTE: no disconnect event is generated by disconnect_now, hence we destroy Player here
  sprite_system.GetSprite(i).kill();
  sprite_system.GetSprite(i).player = std::make_shared<TServerPlayer>();
  NotImplemented("Check if &player is used properly to remove player");
  auto players = GetServerNetwork()->GetPlayers();
  auto peer = player->peer;
  players.erase(std::remove_if(players.begin(), players.end(),
                               [&player](const auto &v) { return v.get() == player; }),
                players.end());

  GetServerNetwork()->CloseConnection(peer, true);

  dobalancebots(1, sprite_system.GetSprite(i).player->team);
}

void servermapchange(std::uint8_t id)
{
  auto &sprite_system = SpriteSystem::Get();
  tmsg_mapchange mapchangemsg;
  tplayer dstplayer;

  mapchangemsg.header.id = msgid_mapchange;
  mapchangemsg.counter = GS::GetGame().GetMapchangecounter();
  strcpy(mapchangemsg.mapname.data(), GS::GetGame().GetMapchange().name.data());
  auto mapchecksum =
    getmapchecksum(GS::GetFileSystem(), GS::GetGame().GetMapchange(), GS::GetGame().GetGameModChecksum());
  mapchangemsg.mapchecksum = mapchecksum;
  GS::GetGame().SetMapChecksum(mapchecksum);

  for (auto &sprite : sprite_system.GetActiveSprites())
  {
    sprite.player->tkwarnings = 0;
    tklist[sprite.num] = "";
    tklistkills[sprite.num] = 0;
  }

  if (id == 0)
  {
    ;
    // NOTE we send to pending players too, otherwise there is a small window where they miss
    // the map change NOTE also that we're using the CONNECTION channel, which is required for
    // all packets that can be sent before a sprite is assigned to the player for proper
    // sequencing with encryption commands.
    //    for DstPlayer in Players do
    //      udp->senddata(&MapChangeMsg, sizeof(MapChangeMsg), DstPlayer.peer,
    //      k_nSteamNetworkingSend_Reliable);
  }
  else if ((sprite_system.GetSprite(id).active) &&
           (sprite_system.GetSprite(id).player->controlmethod == human))
  {
    GetServerNetwork()->SendData(&mapchangemsg, sizeof(mapchangemsg),
                                 sprite_system.GetSprite(id).player->peer, true);
  }
}

void serverflaginfo(std::uint8_t style, std::uint8_t who)
{
  tmsg_serverflaginfo flagmsg;

  flagmsg.header.id = msgid_flaginfo;
  flagmsg.style = style;
  flagmsg.who = who;

  for (auto &sprite : SpriteSystem::Get().GetActiveSprites())
  {
    if (sprite.player->controlmethod == human)
    {
      GetServerNetwork()->SendData(&flagmsg, sizeof(flagmsg), sprite.player->peer, true);
    }
  }
}

void serveridleanimation(std::uint8_t num, std::int16_t style)
{
  tmsg_idleanimation idlemsg;

  idlemsg.header.id = msgid_idleanimation;
  idlemsg.num = num;
  idlemsg.idlerandom = style;

  for (auto &sprite : SpriteSystem::Get().GetActiveSprites())
  {
    if (sprite.player->controlmethod == human)
    {
      GetServerNetwork()->SendData(&idlemsg, sizeof(idlemsg), sprite.player->peer, true);
    }
  }
}

void serversendvoteon(std::uint8_t votestyle, std::int32_t voter, std::string targetname,
                      std::string reason)
{
  tmsg_voteon votemsg;

  votemsg.header.id = msgid_voteon;
  votemsg.votetype = votestyle;
  votemsg.timer = GS::GetGame().GetVoteTimeRemaining();
  votemsg.who = voter;
  stringtoarray(votemsg.targetname.data(), targetname);
  stringtoarray(votemsg.reason.data(), reason);

  for (auto &sprite : SpriteSystem::Get().GetActiveSprites())
  {
    if (sprite.player->controlmethod == human)
    {
      GetServerNetwork()->SendData(&votemsg, sizeof(votemsg), sprite.player->peer, true);
    }
  }
}

void serversendvoteoff()
{
  tmsg_voteoff votemsg;

  votemsg.header.id = msgid_voteoff;

  for (auto &sprite : SpriteSystem::Get().GetActiveSprites())
  {
    if (sprite.player->controlmethod == human)
    {
      GetServerNetwork()->SendData(&votemsg, sizeof(votemsg), sprite.player->peer, true);
    }
  }
}

void serverhandlevotekick(tmsgheader* netmessage, std::int32_t size, NetworkServer& network, TServerPlayer* player)
{
  auto &sprite_system = SpriteSystem::Get();
  tmsg_votekick *votekickmsg;
  std::int32_t i;

  if (!verifypacket(sizeof(tmsg_votekick), size, msgid_votekick))
  {
    return;
  }

  votekickmsg = pmsg_votekick(netmessage);
  i = player->spritenum;

  if (GS::GetGame().IsVoteActive())
  {
    // if a vote against a player is in progress,
    // don't allow that player to vote against himself.
    if (GS::GetGame().GetVoteType() != vote_kick)
    {
      return;
    }
    if (strtoint(GS::GetGame().GetVoteTarget()) == i)
    {
      serversendstringmessage("A vote has been cast against you. You can not vote.", i, 255,
                              msgtype_pub);
      return;
    }

    // check if he already voted
    if (GS::GetGame().HasVoted(i))
    {
      return;
    }

    // check if the vote target is actually the target
    if (GS::GetGame().GetVoteTarget() != inttostr(votekickmsg->num))
    {
      return;
    }

#ifdef SCRIPT
    scrptdispatcher.onvotekick(i, votekickmsg.num);
#endif
    GS::GetGame().countvote(i);
  }
  else
  {
    if (GS::GetGame().IsVoteActive())
    {
      // only allow valid votes
      if ((votekickmsg->num < 1) || (votekickmsg->num > max_players))
      {
        return;
      }
      if (sprite_system.GetSprite(i).player->muted == 1)
      {
        writeconsole(i, "You are muted. You can't cast a vote kick.", server_message_color);
        return;
      }

#ifdef SCRIPT
      if (scrptdispatcher.onvotekickstart(i, votekickmsg.num, string(votekickmsg.reason)))
        return;
#endif

      GS::GetGame().startvote(i, vote_kick, inttostr(votekickmsg->num), votekickmsg->reason.data());
      serversendvoteon(GS::GetGame().GetVoteType(), i, inttostr(votekickmsg->num),
                       votekickmsg->reason.data());
      // Show started votekick in admin console
      GS::GetMainConsole().console(sprite_system.GetSprite(i).player->name +
                                     " started votekick against " +
                                     sprite_system.GetSprite(votekickmsg->num).player->name +
                                     " - Reason:" + std::string(votekickmsg->reason.data()),
                                   vote_message_color);
    }
  }
}

void serverhandlevotemap(tmsgheader* netmessage, std::int32_t size, NetworkServer& network, TServerPlayer* player)
{
  auto &sprite_system = SpriteSystem::Get();
  tmsg_votemap *votemapmsg;
  tmsg_votemapreply votemapreplymsg;
  std::int32_t i;

  if (!verifypacket(sizeof(tmsg_votemap), size, msgid_votemap))
  {
    return;
  }

  votemapmsg = pmsg_votemap(netmessage);
  i = player->spritenum;

  if (votemapmsg->mapid > mapslist.size() - 1)
  {
    return;
  }

  votemapreplymsg.header.id = msgid_votemapreply;
  votemapreplymsg.count = mapslist.size();
  strcpy(votemapreplymsg.mapname.data(), mapslist[votemapmsg->mapid].data());

  GetServerNetwork()->SendData(&votemapreplymsg, sizeof(votemapreplymsg),
                               sprite_system.GetSprite(i).player->peer, true);
}

void serverhandlechangeteam(tmsgheader* netmessage, std::int32_t size, NetworkServer& network, TServerPlayer* player)
{
  auto &sprite_system = SpriteSystem::Get();
  tmsg_changeteam *changeteammsg;
  std::int32_t i;

  if (!verifypacket(sizeof(tmsg_changeteam), size, msgid_changeteam))
  {
    return;
  }
  changeteammsg = pmsg_changeteam(netmessage);
  i = player->spritenum;
  sprite_system.GetSprite(i).changeteam_ServerVariant(changeteammsg->team);
}

void serversyncmsg(std::int32_t tonum)
{
  tmsg_serversyncmsg syncmsg;

  syncmsg.header.id = msgid_serversyncmsg;
  syncmsg.time = GS::GetGame().GetTimelimitcounter();
  if (GS::GetGame().GetMapchangecounter() == 999999999)
  {
    syncmsg.pause = 1;
  }
  else
  {
    syncmsg.pause = 0;
  }

  for (auto &sprite : SpriteSystem::Get().GetActiveSprites())
  {
    if ((tonum == 0) || (sprite.num == tonum))
    {
      if (sprite.player->controlmethod == human)
      {
        GetServerNetwork()->SendData(&syncmsg, sizeof(syncmsg), sprite.player->peer, true);
      }
    }
  }
}
