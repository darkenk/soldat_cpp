#include <SDL3/SDL.h>
#include <cassert>
#include <cstdlib>
#include "Nuklear.hpp"
#define NK_SDL_GPU_IMPLEMENTATION
/*
 * ==============================================================
 *
 *                          IMPLEMENTATION
 *
 * ===============================================================
 */
#ifdef NK_SDL_GPU_IMPLEMENTATION
static unsigned char nuklear_ui_frag_spv[] = {
  0x03, 0x02, 0x23, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x1c, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x03, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x08, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x58, 0x02, 0x00, 0x00,
  0x05, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x00, 0x74, 0x79, 0x70, 0x65, 0x2e, 0x32, 0x64, 0x2e,
  0x69, 0x6d, 0x61, 0x67, 0x65, 0x00, 0x00, 0x00, 0x05, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x74, 0x65, 0x78, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, 0x00, 0x00, 0x00, 0x74, 0x79, 0x70, 0x65,
  0x2e, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x74, 0x65, 0x78, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x00, 0x00,
  0x05, 0x00, 0x06, 0x00, 0x02, 0x00, 0x00, 0x00, 0x69, 0x6e, 0x2e, 0x76, 0x61, 0x72, 0x2e, 0x43,
  0x4f, 0x4c, 0x4f, 0x52, 0x30, 0x00, 0x00, 0x00, 0x05, 0x00, 0x07, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x69, 0x6e, 0x2e, 0x76, 0x61, 0x72, 0x2e, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x30,
  0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x07, 0x00, 0x04, 0x00, 0x00, 0x00, 0x6f, 0x75, 0x74, 0x2e,
  0x76, 0x61, 0x72, 0x2e, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x30, 0x00, 0x00,
  0x05, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x07, 0x00, 0x09, 0x00, 0x00, 0x00, 0x74, 0x79, 0x70, 0x65, 0x2e, 0x73, 0x61, 0x6d,
  0x70, 0x6c, 0x65, 0x64, 0x2e, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x03, 0x00,
  0x0a, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x19, 0x00, 0x09, 0x00, 0x05, 0x00, 0x00, 0x00,
  0x0a, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
  0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x02, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x0d, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x0f, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x11, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x0d, 0x00, 0x00, 0x00, 0x13, 0x00, 0x02, 0x00, 0x12, 0x00, 0x00, 0x00, 0x21, 0x00, 0x03, 0x00,
  0x13, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x03, 0x00, 0x09, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x11, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x36, 0x00, 0x05, 0x00, 0x12, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x14, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x05, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x56, 0x00, 0x05, 0x00, 0x09, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00,
  0x18, 0x00, 0x00, 0x00, 0x57, 0x00, 0x06, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00,
  0x19, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x00, 0x05, 0x00,
  0x0d, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00,
  0x3e, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x01, 0x00,
  0x38, 0x00, 0x01, 0x00};
static unsigned int nuklear_ui_frag_spv_len = 868;

unsigned char nuklear_ui_vert_spv[] = {
  0x03, 0x02, 0x23, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x2a, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x03, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x58, 0x02, 0x00, 0x00,
  0x05, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x74, 0x79, 0x70, 0x65, 0x2e, 0x54, 0x72, 0x61,
  0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00,
  0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x53, 0x63, 0x61,
  0x6c, 0x65, 0x00, 0x00, 0x06, 0x00, 0x06, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x75, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x00, 0x00, 0x05, 0x00, 0x06, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x42, 0x75, 0x66,
  0x66, 0x65, 0x72, 0x00, 0x05, 0x00, 0x06, 0x00, 0x02, 0x00, 0x00, 0x00, 0x69, 0x6e, 0x2e, 0x76,
  0x61, 0x72, 0x2e, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x05, 0x00, 0x07, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x69, 0x6e, 0x2e, 0x76, 0x61, 0x72, 0x2e, 0x54, 0x45, 0x58, 0x43, 0x4f,
  0x4f, 0x52, 0x44, 0x30, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x06, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x69, 0x6e, 0x2e, 0x76, 0x61, 0x72, 0x2e, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x30, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x06, 0x00, 0x06, 0x00, 0x00, 0x00, 0x6f, 0x75, 0x74, 0x2e, 0x76, 0x61, 0x72, 0x2e,
  0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x30, 0x00, 0x00, 0x05, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x6f, 0x75, 0x74, 0x2e, 0x76, 0x61, 0x72, 0x2e, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44,
  0x30, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e,
  0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x03, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x09, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x09, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x05, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x05, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x47, 0x00, 0x03, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x15, 0x00, 0x04, 0x00, 0x0a, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x0a, 0x00, 0x00, 0x00,
  0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x0a, 0x00, 0x00, 0x00,
  0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x03, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x80, 0x3f, 0x17, 0x00, 0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
  0x10, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x11, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x12, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x10, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00, 0x13, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x14, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x13, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x15, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x13, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x16, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x10, 0x00, 0x00, 0x00, 0x13, 0x00, 0x02, 0x00, 0x17, 0x00, 0x00, 0x00, 0x21, 0x00, 0x03, 0x00,
  0x18, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x19, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x11, 0x00, 0x00, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x12, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x12, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x14, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x15, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x15, 0x00, 0x00, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x16, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xbf, 0x36, 0x00, 0x05, 0x00, 0x17, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x1b, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x13, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00, 0x19, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x10, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x85, 0x00, 0x05, 0x00, 0x10, 0x00, 0x00, 0x00,
  0x21, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00,
  0x19, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
  0x81, 0x00, 0x05, 0x00, 0x10, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
  0x23, 0x00, 0x00, 0x00, 0x51, 0x00, 0x05, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00,
  0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x00, 0x05, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x26, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x50, 0x00, 0x07, 0x00,
  0x13, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00,
  0x0e, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x85, 0x00, 0x05, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x28, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x52, 0x00, 0x06, 0x00,
  0x13, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00,
  0x3e, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x01, 0x00, 0x38, 0x00, 0x01, 0x00};
unsigned int nuklear_ui_vert_spv_len = 1248;

struct nk_sdl_device
{
  struct nk_buffer cmds;
  struct nk_draw_null_texture tex_null;
  SDL_GPUTexture *font_tex;
};

struct nk_sdl_vertex
{
  float position[2];
  float uv[2];
  NK_UINT32 col;
};

static struct nk_sdl
{
  SDL_Window *win;
  SDL_GPUDevice *device;
  SDL_GPUShader *vertex_shader;
  SDL_GPUShader *fragment_shader;
  SDL_GPUTextureSamplerBinding font_binding = {NULL, NULL};
  SDL_GPUSampler *font_sampler;
  SDL_GPUGraphicsPipeline *pipeline;
  SDL_GPUBuffer *vertex_buffer;
  SDL_GPUBuffer *index_buffer;
  unsigned int vertex_buffer_size;
  unsigned int index_buffer_size;
  int width, height;
  unsigned int display_width;
  unsigned int display_height;
  struct nk_sdl_device ogl;
  struct nk_context ctx;
  struct nk_font_atlas atlas;
} sdl;

NK_INTERN void nk_create_or_resize_buffer(SDL_GPUBuffer **buffer, uint32_t *old_size,
                                          uint32_t new_size, SDL_GPUBufferUsageFlags usage,
                                          const char *buffer_name)
{
  // Even though this is fairly rarely called.
  SDL_WaitForGPUIdle(sdl.device);
  SDL_ReleaseGPUBuffer(sdl.device, *buffer);

  SDL_GPUBufferCreateInfo buffer_info = {};
  buffer_info.usage = usage;
  buffer_info.size = new_size;
  buffer_info.props = 0;
  if (buffer_name != NULL)
  {
    buffer_info.props = SDL_CreateProperties();
    SDL_SetStringProperty(buffer_info.props, SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING, buffer_name);
  }
  *buffer = SDL_CreateGPUBuffer(sdl.device, &buffer_info);
  *old_size = new_size;
  if (buffer_name != NULL)
  {
    SDL_DestroyProperties(buffer_info.props);
  }
  assert(*buffer != NULL &&
         "Failed to create GPU Buffer, call SDL_GetError() for more information");
}

void nk_sdl_prepare_render_data(enum nk_anti_aliasing AA, SDL_GPUCommandBuffer *command_buffer,
                                unsigned int fb_width, unsigned int fb_height)
{
  struct nk_buffer vbuf, ebuf;
  sdl.display_height = fb_height;
  sdl.display_width = fb_width;

  /* fill converting configuration */
  struct nk_convert_config config;
  static const struct nk_draw_vertex_layout_element vertex_layout[] = {
    {NK_VERTEX_POSITION, NK_FORMAT_FLOAT, NK_OFFSETOF(struct nk_sdl_vertex, position)},
    {NK_VERTEX_TEXCOORD, NK_FORMAT_FLOAT, NK_OFFSETOF(struct nk_sdl_vertex, uv)},
    {NK_VERTEX_COLOR, NK_FORMAT_R8G8B8A8, NK_OFFSETOF(struct nk_sdl_vertex, col)},
    {NK_VERTEX_LAYOUT_END}};
  memset(&config, 0, sizeof(config));
  config.vertex_layout = vertex_layout;
  config.vertex_size = sizeof(struct nk_sdl_vertex);
  config.vertex_alignment = NK_ALIGNOF(struct nk_sdl_vertex);
  config.tex_null = sdl.ogl.tex_null;
  config.circle_segment_count = 22;
  config.curve_segment_count = 22;
  config.arc_segment_count = 22;
  config.global_alpha = 1.0f;
  config.shape_AA = AA;
  config.line_AA = AA;

  /* convert shapes into vertexes */
  nk_buffer_init_default(&vbuf);
  nk_buffer_init_default(&ebuf);
  nk_convert(&sdl.ctx, &sdl.ogl.cmds, &vbuf, &ebuf, &config);

  uint32_t vertex_size = vbuf.size; // * sizeof(struct nk_sdl_vertex);
  uint32_t index_size = ebuf.size;  // * sizeof(nk_draw_index);
  if (sdl.vertex_buffer == NULL || sdl.vertex_buffer_size < vertex_size)
    nk_create_or_resize_buffer(&sdl.vertex_buffer, &sdl.vertex_buffer_size, vertex_size,
                               SDL_GPU_BUFFERUSAGE_VERTEX, "nuklear_vertex_buffer");
  if (sdl.index_buffer == NULL || sdl.index_buffer_size < index_size)
    nk_create_or_resize_buffer(&sdl.index_buffer, &sdl.index_buffer_size, index_size,
                               SDL_GPU_BUFFERUSAGE_INDEX, "nuklear_index_buffer");

  // FIXME: It feels like more code could be shared there.
  SDL_GPUTransferBufferCreateInfo vertex_transferbuffer_info = {};
  vertex_transferbuffer_info.usage = SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD;
  vertex_transferbuffer_info.size = vertex_size;
  SDL_GPUTransferBufferCreateInfo index_transferbuffer_info = {};
  index_transferbuffer_info.usage = SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD;
  index_transferbuffer_info.size = index_size;

  SDL_GPUTransferBuffer *vertex_transferbuffer =
    SDL_CreateGPUTransferBuffer(sdl.device, &vertex_transferbuffer_info);
  assert(vertex_transferbuffer != NULL &&
         "Failed to create the vertex transfer buffer, call SDL_GetError() for more information");
  SDL_GPUTransferBuffer *index_transferbuffer =
    SDL_CreateGPUTransferBuffer(sdl.device, &index_transferbuffer_info);
  assert(index_transferbuffer != NULL &&
         "Failed to create the index transfer buffer, call SDL_GetError() for more information");

  nk_sdl_vertex *vtx_dst =
    (nk_sdl_vertex *)SDL_MapGPUTransferBuffer(sdl.device, vertex_transferbuffer, true);
  nk_draw_index *idx_dst =
    (nk_draw_index *)SDL_MapGPUTransferBuffer(sdl.device, index_transferbuffer, true);
  memcpy(vtx_dst, vbuf.memory.ptr, vertex_size);
  memcpy(idx_dst, ebuf.memory.ptr, index_size);

  SDL_UnmapGPUTransferBuffer(sdl.device, vertex_transferbuffer);
  SDL_UnmapGPUTransferBuffer(sdl.device, index_transferbuffer);

  SDL_GPUTransferBufferLocation vertex_buffer_location = {};
  vertex_buffer_location.offset = 0;
  vertex_buffer_location.transfer_buffer = vertex_transferbuffer;
  SDL_GPUTransferBufferLocation index_buffer_location = {};
  index_buffer_location.offset = 0;
  index_buffer_location.transfer_buffer = index_transferbuffer;

  SDL_GPUBufferRegion vertex_buffer_region = {};
  vertex_buffer_region.buffer = sdl.vertex_buffer;
  vertex_buffer_region.offset = 0;
  vertex_buffer_region.size = vertex_size;

  SDL_GPUBufferRegion index_buffer_region = {};
  index_buffer_region.buffer = sdl.index_buffer;
  index_buffer_region.offset = 0;
  index_buffer_region.size = index_size;

  SDL_GPUCopyPass *copy_pass = SDL_BeginGPUCopyPass(command_buffer);
  SDL_UploadToGPUBuffer(copy_pass, &vertex_buffer_location, &vertex_buffer_region, true);
  SDL_UploadToGPUBuffer(copy_pass, &index_buffer_location, &index_buffer_region, true);
  SDL_EndGPUCopyPass(copy_pass);
  SDL_ReleaseGPUTransferBuffer(sdl.device, index_transferbuffer);
  SDL_ReleaseGPUTransferBuffer(sdl.device, vertex_transferbuffer);

  nk_buffer_free(&vbuf);
  nk_buffer_free(&ebuf);
}

NK_INTERN void nk_create_shaders()
{
  const char *driver = SDL_GetGPUDeviceDriver(sdl.device);

  SDL_GPUShaderCreateInfo vertex_shader_info = {};
  vertex_shader_info.entrypoint = "main";
  vertex_shader_info.stage = SDL_GPU_SHADERSTAGE_VERTEX;
  vertex_shader_info.num_uniform_buffers = 1;
  vertex_shader_info.num_storage_buffers = 0;
  vertex_shader_info.num_storage_textures = 0;
  vertex_shader_info.num_samplers = 0;
  vertex_shader_info.props = SDL_CreateProperties();
  SDL_SetStringProperty(vertex_shader_info.props, SDL_PROP_GPU_SHADER_CREATE_NAME_STRING,
                        "nuklear_vertex_shader");

  SDL_GPUShaderCreateInfo fragment_shader_info = {};
  fragment_shader_info.entrypoint = "main";
  fragment_shader_info.stage = SDL_GPU_SHADERSTAGE_FRAGMENT;
  fragment_shader_info.num_samplers = 1;
  fragment_shader_info.num_storage_buffers = 0;
  fragment_shader_info.num_storage_textures = 0;
  fragment_shader_info.num_uniform_buffers = 0;
  fragment_shader_info.props = SDL_CreateProperties();
  SDL_SetStringProperty(fragment_shader_info.props, SDL_PROP_GPU_SHADER_CREATE_NAME_STRING,
                        "nuklear_fragment_shader");

  if (strcmp(driver, "vulkan") == 0)
  {
    vertex_shader_info.format = SDL_GPU_SHADERFORMAT_SPIRV;
    vertex_shader_info.code = nuklear_ui_vert_spv;
    vertex_shader_info.code_size = nuklear_ui_vert_spv_len;
    fragment_shader_info.format = SDL_GPU_SHADERFORMAT_SPIRV;
    fragment_shader_info.code = nuklear_ui_frag_spv;
    fragment_shader_info.code_size = nuklear_ui_frag_spv_len;
  }
  else
  {
    assert(0 && "Unsupported GPU driver");
  }
  sdl.vertex_shader = SDL_CreateGPUShader(sdl.device, &vertex_shader_info);
  sdl.fragment_shader = SDL_CreateGPUShader(sdl.device, &fragment_shader_info);
  assert(sdl.vertex_shader != NULL &&
         "Failed to create vertex shader, call SDL_GetError() for more information");
  assert(sdl.fragment_shader != NULL &&
         "Failed to create fragment shader, call SDL_GetError() for more information");
  SDL_DestroyProperties(vertex_shader_info.props);
  SDL_DestroyProperties(fragment_shader_info.props);
}

NK_INTERN void nk_sdl_create_font_sampler()
{
  // Bilinear sampling is required by default. Set 'io.Fonts->Flags |=
  // ImFontAtlasFlags_NoBakedLines' or 'style.AntiAliasedLinesUseTex = false' to allow point/nearest
  // sampling.
  SDL_GPUSamplerCreateInfo sampler_info = {};
  sampler_info.min_filter = SDL_GPU_FILTER_LINEAR;
  sampler_info.mag_filter = SDL_GPU_FILTER_LINEAR;
  sampler_info.mipmap_mode = SDL_GPU_SAMPLERMIPMAPMODE_LINEAR;
  sampler_info.address_mode_u = SDL_GPU_SAMPLERADDRESSMODE_CLAMP_TO_EDGE;
  sampler_info.address_mode_v = SDL_GPU_SAMPLERADDRESSMODE_CLAMP_TO_EDGE;
  sampler_info.address_mode_w = SDL_GPU_SAMPLERADDRESSMODE_CLAMP_TO_EDGE;
  sampler_info.mip_lod_bias = 0.0f;
  sampler_info.min_lod = -1000.0f;
  sampler_info.max_lod = 1000.0f;
  sampler_info.enable_anisotropy = false;
  sampler_info.max_anisotropy = 1.0f;
  sampler_info.enable_compare = false;
  sampler_info.props = SDL_CreateProperties();
  SDL_SetStringProperty(sampler_info.props, SDL_PROP_GPU_SAMPLER_CREATE_NAME_STRING,
                        "nuklear_font_sampler");

  sdl.font_sampler = SDL_CreateGPUSampler(sdl.device, &sampler_info);
  sdl.font_binding.sampler = sdl.font_sampler;
  assert(sdl.font_sampler != NULL &&
         "Failed to create font sampler, call SDL_GetError() for more information");
  SDL_DestroyProperties(sampler_info.props);
}

NK_INTERN void nk_sdl_create_graphics_pipeline()
{
  SDL_GPUVertexBufferDescription vertex_buffer_desc[1];
  vertex_buffer_desc[0].slot = 0;
  vertex_buffer_desc[0].input_rate = SDL_GPU_VERTEXINPUTRATE_VERTEX;
  vertex_buffer_desc[0].instance_step_rate = 0;
  vertex_buffer_desc[0].pitch = sizeof(nk_sdl_vertex);

  SDL_GPUVertexAttribute vertex_attributes[3];
  vertex_attributes[0].buffer_slot = 0;
  vertex_attributes[0].format = SDL_GPU_VERTEXELEMENTFORMAT_FLOAT2;
  vertex_attributes[0].location = 0;
  vertex_attributes[0].offset = NK_OFFSETOF(nk_sdl_vertex, position);

  vertex_attributes[1].buffer_slot = 0;
  vertex_attributes[1].format = SDL_GPU_VERTEXELEMENTFORMAT_FLOAT2;
  vertex_attributes[1].location = 1;
  vertex_attributes[1].offset = NK_OFFSETOF(nk_sdl_vertex, uv);

  vertex_attributes[2].buffer_slot = 0;
  vertex_attributes[2].format = SDL_GPU_VERTEXELEMENTFORMAT_UBYTE4_NORM;
  vertex_attributes[2].location = 2;
  vertex_attributes[2].offset = NK_OFFSETOF(nk_sdl_vertex, col);

  SDL_GPUVertexInputState vertex_input_state = {};
  vertex_input_state.num_vertex_attributes = 3;
  vertex_input_state.vertex_attributes = vertex_attributes;
  vertex_input_state.num_vertex_buffers = 1;
  vertex_input_state.vertex_buffer_descriptions = vertex_buffer_desc;

  SDL_GPURasterizerState rasterizer_state = {};
  rasterizer_state.fill_mode = SDL_GPU_FILLMODE_FILL;
  rasterizer_state.cull_mode = SDL_GPU_CULLMODE_NONE;
  rasterizer_state.front_face = SDL_GPU_FRONTFACE_COUNTER_CLOCKWISE;
  rasterizer_state.enable_depth_bias = false;
  rasterizer_state.enable_depth_clip = false;

  SDL_GPUMultisampleState multisample_state = {};
  multisample_state.sample_count = SDL_GPU_SAMPLECOUNT_1;
  multisample_state.enable_mask = false;

  SDL_GPUDepthStencilState depth_stencil_state = {};
  depth_stencil_state.enable_depth_test = false;
  depth_stencil_state.enable_depth_write = false;
  depth_stencil_state.enable_stencil_test = false;

  SDL_GPUColorTargetBlendState blend_state = {};
  blend_state.enable_blend = true;
  blend_state.src_color_blendfactor = SDL_GPU_BLENDFACTOR_SRC_ALPHA;
  blend_state.dst_color_blendfactor = SDL_GPU_BLENDFACTOR_ONE_MINUS_SRC_ALPHA;
  blend_state.color_blend_op = SDL_GPU_BLENDOP_ADD;
  blend_state.src_alpha_blendfactor = SDL_GPU_BLENDFACTOR_ONE;
  blend_state.dst_alpha_blendfactor = SDL_GPU_BLENDFACTOR_ONE_MINUS_SRC_ALPHA;
  blend_state.alpha_blend_op = SDL_GPU_BLENDOP_ADD;
  blend_state.color_write_mask = SDL_GPU_COLORCOMPONENT_R | SDL_GPU_COLORCOMPONENT_G |
                                 SDL_GPU_COLORCOMPONENT_B | SDL_GPU_COLORCOMPONENT_A;

  SDL_GPUColorTargetDescription color_target_desc[1];
  color_target_desc[0].format = SDL_GetGPUSwapchainTextureFormat(
    sdl.device, sdl.win); // TODO: This is a hack, we should have a way to get the swapchain format
  color_target_desc[0].blend_state = blend_state;

  SDL_GPUGraphicsPipelineTargetInfo target_info = {};
  target_info.num_color_targets = 1;
  target_info.color_target_descriptions = color_target_desc;
  target_info.has_depth_stencil_target = false;

  SDL_GPUGraphicsPipelineCreateInfo pipeline_info = {};
  pipeline_info.vertex_shader = sdl.vertex_shader;
  pipeline_info.fragment_shader = sdl.fragment_shader;
  pipeline_info.vertex_input_state = vertex_input_state;
  pipeline_info.primitive_type = SDL_GPU_PRIMITIVETYPE_TRIANGLELIST;
  pipeline_info.rasterizer_state = rasterizer_state;
  pipeline_info.multisample_state = multisample_state;
  pipeline_info.depth_stencil_state = depth_stencil_state;
  pipeline_info.target_info = target_info;
  pipeline_info.props = SDL_CreateProperties();
  SDL_SetStringProperty(pipeline_info.props, SDL_PROP_GPU_GRAPHICSPIPELINE_CREATE_NAME_STRING,
                        "nuklear_graphics_pipeline");

  sdl.pipeline = SDL_CreateGPUGraphicsPipeline(sdl.device, &pipeline_info);
  assert(sdl.pipeline != NULL &&
         "Failed to create graphics pipeline, call SDL_GetError() for more information");
  SDL_DestroyProperties(pipeline_info.props);
}

NK_INTERN void nk_sdl_setup_render_state(SDL_GPUGraphicsPipeline *pipeline,
                                         SDL_GPUCommandBuffer *command_buffer,
                                         SDL_GPURenderPass *render_pass, uint32_t fb_width,
                                         uint32_t fb_height)
{
  // Bind graphics pipeline
  SDL_BindGPUGraphicsPipeline(render_pass, pipeline);

  // Bind Vertex And Index Buffers
  if (sdl.vertex_buffer_size > 0)
  {
    SDL_GPUBufferBinding vertex_buffer_binding = {};
    vertex_buffer_binding.buffer = sdl.vertex_buffer;
    vertex_buffer_binding.offset = 0;
    SDL_GPUBufferBinding index_buffer_binding = {};
    index_buffer_binding.buffer = sdl.index_buffer;
    index_buffer_binding.offset = 0;
    SDL_BindGPUVertexBuffers(render_pass, 0, &vertex_buffer_binding, 1);
    SDL_BindGPUIndexBuffer(render_pass, &index_buffer_binding,
                           sizeof(nk_draw_index) == 2 ? SDL_GPU_INDEXELEMENTSIZE_16BIT
                                                      : SDL_GPU_INDEXELEMENTSIZE_32BIT);
  }

  // Setup viewport
  SDL_GPUViewport viewport = {};
  viewport.x = 0;
  viewport.y = 0;
  viewport.w = (float)sdl.display_width;
  viewport.h = (float)sdl.display_height;
  viewport.min_depth = 0.0f;
  viewport.max_depth = 1.0f;
  SDL_SetGPUViewport(render_pass, &viewport);

  // Setup scale and translation
  // Our visible imgui space lies from draw_data->DisplayPps (top left) to
  // draw_data->DisplayPos+data_data->DisplaySize (bottom right). DisplayPos is (0,0) for single
  // viewport apps.
  struct UBO
  {
    float scale[2];
    float translation[2];
  } ubo;
  ubo.scale[0] = 2.0f / (float)sdl.display_width;
  ubo.scale[1] = 2.0f / (float)sdl.display_height;
  ubo.translation[0] = -1.0f;
  ubo.translation[1] = -1.0f;
  SDL_PushGPUVertexUniformData(command_buffer, 0, &ubo, sizeof(UBO));
}

NK_INTERN void nk_sdl_device_upload_atlas(const void *image, int width, int height)
{
  // Destroy existing texture (if any)
  if (sdl.ogl.font_tex)
  {
    SDL_WaitForGPUIdle(sdl.device);
    SDL_ReleaseGPUTexture(sdl.device, sdl.ogl.font_tex);
  }

  uint32_t upload_size = width * height * 4 * sizeof(char);

  // Create the Image:
  {
    SDL_GPUTextureCreateInfo texture_info = {};
    texture_info.type = SDL_GPU_TEXTURETYPE_2D;
    texture_info.format = SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UNORM;
    texture_info.usage = SDL_GPU_TEXTUREUSAGE_SAMPLER;
    texture_info.width = width;
    texture_info.height = height;
    texture_info.layer_count_or_depth = 1;
    texture_info.num_levels = 1;
    texture_info.sample_count = SDL_GPU_SAMPLECOUNT_1;
    texture_info.props = SDL_CreateProperties();
    SDL_SetStringProperty(texture_info.props, SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING,
                          "nuklear_font_texture");

    sdl.ogl.font_tex = SDL_CreateGPUTexture(sdl.device, &texture_info);
    assert(sdl.ogl.font_tex && "Failed to create font texture, call SDL_GetError() for more info");
    SDL_DestroyProperties(texture_info.props);
  }

  // Assign the texture to the TextureSamplerBinding
  sdl.font_binding.texture = sdl.ogl.font_tex;

  // Create all the upload structures and upload:
  {
    SDL_GPUTransferBufferCreateInfo transferbuffer_info = {};
    transferbuffer_info.usage = SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD;
    transferbuffer_info.size = upload_size;

    SDL_GPUTransferBuffer *transferbuffer =
      SDL_CreateGPUTransferBuffer(sdl.device, &transferbuffer_info);
    assert(transferbuffer != NULL &&
           "Failed to create font transfer buffer, call SDL_GetError() for more information");

    void *texture_ptr = SDL_MapGPUTransferBuffer(sdl.device, transferbuffer, false);
    memcpy(texture_ptr, image, upload_size);
    SDL_UnmapGPUTransferBuffer(sdl.device, transferbuffer);

    SDL_GPUTextureTransferInfo transfer_info = {};
    transfer_info.offset = 0;
    transfer_info.transfer_buffer = transferbuffer;

    SDL_GPUTextureRegion texture_region = {};
    texture_region.texture = sdl.ogl.font_tex;
    texture_region.w = width;
    texture_region.h = height;
    texture_region.d = 1;

    SDL_GPUCommandBuffer *cmd = SDL_AcquireGPUCommandBuffer(sdl.device);
    SDL_GPUCopyPass *copy_pass = SDL_BeginGPUCopyPass(cmd);
    SDL_UploadToGPUTexture(copy_pass, &transfer_info, &texture_region, false);
    SDL_EndGPUCopyPass(copy_pass);
    SDL_SubmitGPUCommandBuffer(cmd);
    SDL_ReleaseGPUTransferBuffer(sdl.device, transferbuffer);
  }
}

NK_API void nk_sdl_render(enum nk_anti_aliasing AA, SDL_GPUCommandBuffer *command_buffer,
                          SDL_GPURenderPass *render_pass)
{
  /* setup global state */
  struct nk_sdl_device *dev = &sdl.ogl;

  nk_sdl_setup_render_state(sdl.pipeline, command_buffer, render_pass, sdl.display_width,
                            sdl.display_height);

  {

    const struct nk_draw_command *cmd;
    int global_idx_offset = 0;

    nk_draw_foreach(cmd, &sdl.ctx, &dev->cmds)
    {
      if (!cmd->elem_count)
        continue;

      {
        SDL_Rect r;
        r.x = NK_MAX(cmd->clip_rect.x, 0.0f);
        r.y = NK_MAX(cmd->clip_rect.y, 0.0f);
        r.w = cmd->clip_rect.w; // x + w?
        r.h = cmd->clip_rect.h; // y + h?
        SDL_SetGPUScissor(render_pass, &r);
      }

      {

        SDL_BindGPUFragmentSamplers(render_pass, 0,
                                    (SDL_GPUTextureSamplerBinding *)(cmd->texture.ptr), 1);
        SDL_DrawGPUIndexedPrimitives(render_pass, cmd->elem_count, 1, global_idx_offset, 0, 0);
      }
      global_idx_offset += cmd->elem_count;
    }
    SDL_Rect scissor_rect{0, 0, (int)sdl.display_width, (int)sdl.display_height};
    SDL_SetGPUScissor(render_pass, &scissor_rect);

    nk_clear(&sdl.ctx);
    nk_buffer_clear(&dev->cmds);
  }
}

static void nk_sdl_clipboard_paste(nk_handle usr, struct nk_text_edit *edit)
{
  const char *text = SDL_GetClipboardText();
  if (text)
    nk_textedit_paste(edit, text, nk_strlen(text));
  (void)usr;
}

static void nk_sdl_clipboard_copy(nk_handle usr, const char *text, int len)
{
  char *str = 0;
  (void)usr;
  if (!len)
    return;
  str = (char *)malloc((size_t)len + 1);
  if (!str)
    return;
  memcpy(str, text, (size_t)len);
  str[len] = '\0';
  SDL_SetClipboardText(str);
  free(str);
}

NK_API struct nk_context *nk_sdl_init(SDL_Window *win, SDL_GPUDevice *device)
{
  sdl.win = win;
  sdl.device = device;
  SDL_GetWindowSize(sdl.win, &sdl.width, &sdl.height);
  nk_init_default(&sdl.ctx, 0);
  sdl.ctx.clip.copy = nk_sdl_clipboard_copy;
  sdl.ctx.clip.paste = nk_sdl_clipboard_paste;
  sdl.ctx.clip.userdata = nk_handle_ptr(0);
  nk_buffer_init_default(&sdl.ogl.cmds);
  nk_create_shaders();
  nk_sdl_create_font_sampler();
  nk_sdl_create_graphics_pipeline();
  sdl.index_buffer = NULL;
  sdl.vertex_buffer = NULL;
  sdl.index_buffer_size = 0;
  sdl.vertex_buffer_size = 0;
  return &sdl.ctx;
}

NK_API void nk_sdl_font_stash_begin(struct nk_font_atlas **atlas)
{
  nk_font_atlas_init_default(&sdl.atlas);
  nk_font_atlas_begin(&sdl.atlas);
  *atlas = &sdl.atlas;
}

NK_API void nk_sdl_font_stash_end(void)
{
  const void *image;
  int w, h;
  image = nk_font_atlas_bake(&sdl.atlas, &w, &h, NK_FONT_ATLAS_RGBA32);
  nk_sdl_device_upload_atlas(image, w, h);
  nk_font_atlas_end(&sdl.atlas, nk_handle_ptr(&sdl.font_binding), &sdl.ogl.tex_null);
  if (sdl.atlas.default_font)
    nk_style_set_font(&sdl.ctx, &sdl.atlas.default_font->handle);
}

NK_API int nk_sdl_handle_event(SDL_Event *evt)
{
  struct nk_context *ctx = &sdl.ctx;

  switch (evt->type)
  {
  case SDL_EVENT_KEY_UP: /* KEYUP & KEYDOWN share same routine */
  case SDL_EVENT_KEY_DOWN: {
    int down = evt->type == SDL_EVENT_KEY_DOWN;
    const bool *state = SDL_GetKeyboardState(0);
    switch (evt->key.key)
    {
    case SDLK_RSHIFT: /* RSHIFT & LSHIFT share same routine */
    case SDLK_LSHIFT:
      nk_input_key(ctx, NK_KEY_SHIFT, down);
      break;
    case SDLK_DELETE:
      nk_input_key(ctx, NK_KEY_DEL, down);
      break;
    case SDLK_RETURN:
      nk_input_key(ctx, NK_KEY_ENTER, down);
      break;
    case SDLK_TAB:
      nk_input_key(ctx, NK_KEY_TAB, down);
      break;
    case SDLK_BACKSPACE:
      nk_input_key(ctx, NK_KEY_BACKSPACE, down);
      break;
    case SDLK_HOME:
      nk_input_key(ctx, NK_KEY_TEXT_START, down);
      nk_input_key(ctx, NK_KEY_SCROLL_START, down);
      break;
    case SDLK_END:
      nk_input_key(ctx, NK_KEY_TEXT_END, down);
      nk_input_key(ctx, NK_KEY_SCROLL_END, down);
      break;
    case SDLK_PAGEDOWN:
      nk_input_key(ctx, NK_KEY_SCROLL_DOWN, down);
      break;
    case SDLK_PAGEUP:
      nk_input_key(ctx, NK_KEY_SCROLL_UP, down);
      break;
    case SDLK_Z:
      nk_input_key(ctx, NK_KEY_TEXT_UNDO, down && state[SDL_SCANCODE_LCTRL]);
      break;
    case SDLK_R:
      nk_input_key(ctx, NK_KEY_TEXT_REDO, down && state[SDL_SCANCODE_LCTRL]);
      break;
    case SDLK_C:
      nk_input_key(ctx, NK_KEY_COPY, down && state[SDL_SCANCODE_LCTRL]);
      break;
    case SDLK_V:
      nk_input_key(ctx, NK_KEY_PASTE, down && state[SDL_SCANCODE_LCTRL]);
      break;
    case SDLK_X:
      nk_input_key(ctx, NK_KEY_CUT, down && state[SDL_SCANCODE_LCTRL]);
      break;
    case SDLK_B:
      nk_input_key(ctx, NK_KEY_TEXT_LINE_START, down && state[SDL_SCANCODE_LCTRL]);
      break;
    case SDLK_E:
      nk_input_key(ctx, NK_KEY_TEXT_LINE_END, down && state[SDL_SCANCODE_LCTRL]);
      break;
    case SDLK_UP:
      nk_input_key(ctx, NK_KEY_UP, down);
      break;
    case SDLK_DOWN:
      nk_input_key(ctx, NK_KEY_DOWN, down);
      break;
    case SDLK_LEFT:
      if (state[SDL_SCANCODE_LCTRL])
        nk_input_key(ctx, NK_KEY_TEXT_WORD_LEFT, down);
      else
        nk_input_key(ctx, NK_KEY_LEFT, down);
      break;
    case SDLK_RIGHT:
      if (state[SDL_SCANCODE_LCTRL])
        nk_input_key(ctx, NK_KEY_TEXT_WORD_RIGHT, down);
      else
        nk_input_key(ctx, NK_KEY_RIGHT, down);
      break;
    }
    return 1;
  }

  case SDL_EVENT_MOUSE_BUTTON_UP: /* MOUSEBUTTONUP & MOUSEBUTTONDOWN share same routine */
  case SDL_EVENT_MOUSE_BUTTON_DOWN: {
    int down = evt->button.down;
    const int x = evt->button.x, y = evt->button.y;
    switch (evt->button.button)
    {
    case SDL_BUTTON_LEFT:
      if (evt->button.clicks > 1)
        nk_input_button(ctx, NK_BUTTON_DOUBLE, x, y, down);
      nk_input_button(ctx, NK_BUTTON_LEFT, x, y, down);
      break;
    case SDL_BUTTON_MIDDLE:
      nk_input_button(ctx, NK_BUTTON_MIDDLE, x, y, down);
      break;
    case SDL_BUTTON_RIGHT:
      nk_input_button(ctx, NK_BUTTON_RIGHT, x, y, down);
      break;
    }
  }
    return 1;

  case SDL_EVENT_MOUSE_MOTION:
    if (ctx->input.mouse.grabbed)
    {
      int x = (int)ctx->input.mouse.prev.x, y = (int)ctx->input.mouse.prev.y;
      nk_input_motion(ctx, x + evt->motion.xrel, y + evt->motion.yrel);
    }
    else
      nk_input_motion(ctx, evt->motion.x, evt->motion.y);
    return 1;

  case SDL_EVENT_TEXT_INPUT: {
    nk_glyph glyph;
    memcpy(glyph, evt->text.text, NK_UTF_SIZE);
    nk_input_glyph(ctx, glyph);
  }
    return 1;

  case SDL_EVENT_MOUSE_WHEEL:
    nk_input_scroll(ctx, nk_vec2((float)evt->wheel.x, (float)evt->wheel.y));
    return 1;
  }
  return 0;
}

NK_API
void nk_sdl_shutdown(void)
{
  struct nk_sdl_device *dev = &sdl.ogl;

  SDL_ReleaseGPUShader(sdl.device, sdl.fragment_shader);
  SDL_ReleaseGPUShader(sdl.device, sdl.vertex_shader);
  SDL_ReleaseGPUTexture(sdl.device, dev->font_tex);
  SDL_ReleaseGPUSampler(sdl.device, sdl.font_sampler);
  SDL_ReleaseGPUGraphicsPipeline(sdl.device, sdl.pipeline);
  nk_font_atlas_clear(&sdl.atlas);
  nk_free(&sdl.ctx);
  nk_buffer_free(&dev->cmds);
  memset(&sdl, 0, sizeof(sdl));
}

#endif /* NK_SDL_GPU_IMPLEMENTATION */